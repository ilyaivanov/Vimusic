{"version":3,"sources":["configuration.ts","api/index.ts","api/youtube.ts","Search/SearchInput.tsx","utils/hooks.ts","SandboxContext.tsx","utils/array.ts","state/treeUtils.ts","state/reducer.ts","keyHandlers/actions.ts","keyHandlers/traversal.ts","keyHandlers/nodeSwap.ts","keyHandlers/index.ts","components/Player.tsx","state/player.ts","components/Focusable.tsx","components/RowItem.tsx","components/List.tsx","components/Tree.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["searchVideos","term","fetch","then","response","json","data","items","filter","v","id","videoId","map","s","text","snippet","title","real","fetchSimilarVideos","SearchInput","_ref","onSearched","_useState","useState","_useState2","Object","slicedToArray","setText","value","delay","debouncedValue","setDebouncedValue","useEffect","handler","setTimeout","clearTimeout","useDebounce","_useState3","_useState4","setIsSearching","videos","nodes","Math","random","youtubeId","react_default","a","createElement","tabIndex","onChange","e","target","type","style","width","boxSizing","CountContext","React","createContext","SandboxContext","children","app","dispatch","Provider","nextItem","array","item","indexOf","contains","last","length","isFirst","insertBefore","insertBofore","valueToInsert","index","copy","toConsumableArray","splice","getPrevious","removeItem","swapLeft","concat","slice","swapRight","getContext","state","nodeId","rootNodes","parentKey","getParentKey","Error","getParentContext","isRoot","parent","context","key","keys","find","getDeepestChild","node","hasChildren","isNodeHidden","getChildren","updateNode","props","objectSpread","defineProperty","isChildrenHidden","isNodeLoading","isLoading","isEditingCurrentNode","selectedNode","isEditing","reducer","action","savedState","tree","forEach","newId","withNode","placeBefore","nextSelectedNode","newnodes","deleteAllChildren","newRoot","parentId","newState","c","child","roots","useAppState","useReducer","stopEditNode","editAction","showChildren","hideChildren","startLoading","endLoading","setChildren","setRoots","selectNode","codes","ArrowDown","parentContext","ArrowUp","previousNode","ArrowRight","setVideosAsChildren","ArrowLeft","video","applySwapMove","swap","removeSelectedFromContext","newRoots","insertSelectedInParent","grandParent","newChildren","insertAfter","appendSelectedToPreviousNode","onKeyPress","event","code","createNode","isSwapping","swapSelectedNodeDown","swapSelectedNodeUp","swapSelectedNodeLeft","swapSelectedNodeRight","handleTraversal","deleteNode","shiftKey","metaKey","Player","visible","react","position","right","bottom","display","undefined","YouTube","opts","height","playerVars","autoplay","isPlaying","youtubeVideoId","Focusable","handleEvent","deps","focus","setFocus","window","document","addEventListener","removeEventListener","className","flex","onFocus","onBlur","RowItem","level","_useAppStateFromConte","useContext","_useAppStateFromConte2","isSelected","txt1","useRef","current","fontWeight","paddingLeft","backgroundColor","ref","List","selectedId","nodesToShow","_ref$level","n","RowItem_RowItem","Tree","List_List","App","_useAppState","_useAppState2","searchNodes","searchDispatch","_useAppState3","_useAppState4","favoritesNodes","favoritesDispatch","_usePlayer","_usePlayer2","playerState","dispatchPlayAction","handlePlayerKeys","console","warn","saved","localStorage","getItem","JSON","parse","setItem","stringify","flexDirection","alignItems","SandboxContext_SandboxContext","textAlign","Boolean","location","hostname","match","ReactDOM","render","src_App","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.925bae81.chunk.js","sourcesContent":["export const USE_REAL_API = true;\n\n","import {USE_REAL_API} from \"../configuration\";\n\nimport * as faked from \"./faked/youtube\";\nimport * as real from \"./youtube\";\n\nexport const searchVideos = (term: string): Promise<Video[]> =>\n  USE_REAL_API ? real.searchVideos(term) : faked.searchVideos(term);\n\nexport const fetchSimilarVideos = (videoId: string): Promise<Video[]> =>\n  USE_REAL_API ? real.searchSimilar(videoId) : faked.searchVideos(videoId);\n\nexport interface Video {\n  text: string;\n  id: string;\n}\n","import {Video} from \"./index\";\nimport {SearchResponse} from \"./generated/searchResponse\";\nimport {SimilarResponse} from \"./generated/similarResponse\";\n\nexport const searchVideos = (term: string): Promise<Video[]> =>\n  fetch(\n    \"https://www.googleapis.com/youtube/v3/search?part=snippet&shart=mostPopular&maxResults=10&key=AIzaSyBsCL-zrXWd9S2FKRSDVfz7dOo783LQkLk&q=\" +\n    term\n  )\n    .then(response => response.json())\n    .then((data: SearchResponse) =>\n      data.items\n        .filter(v => v.id.videoId)\n        .map(s => {\n          return {text: s.snippet.title, id: s.id.videoId};\n        })\n    );\n\nexport const searchSimilar = (videoId: string): Promise<Video[]> =>\n  fetch(\n    \"https://www.googleapis.com/youtube/v3/search?part=snippet&type=video&key=AIzaSyBsCL-zrXWd9S2FKRSDVfz7dOo783LQkLk&relatedToVideoId=\" +\n    videoId\n  )\n    .then(response => response.json())\n    .then((data: SimilarResponse) =>\n      data.items\n        .filter(v => v.id.videoId)\n        .map(s => {\n          return {text: s.snippet.title, id: s.id.videoId};\n        })\n    );\n","import React, {useEffect, useState} from \"react\";\nimport {useDebounce} from \"../utils/hooks\";\nimport {searchVideos} from \"../api\";\nimport {TreeDefinition} from \"../types\";\n\ninterface Props {\n  onSearched: (nodes: TreeDefinition[]) => void;\n}\n\nexport default ({onSearched}: Props) => {\n  const [text, setText] = useState(\"\");\n  const value = useDebounce(text, 500);\n  const [isSearching, setIsSearching] = useState(false);\n\n  useEffect(() => {\n    if (value) {\n      setIsSearching(true);\n      searchVideos(value).then(videos => {\n        setIsSearching(false);\n        const nodes: TreeDefinition[] = videos.map(v => ({\n          id: Math.random() + '',\n          text: v.text,\n          youtubeId: v.id\n        }));\n        onSearched(nodes);\n      });\n    }\n  }, [value]);\n\n  return (\n    <input\n      tabIndex={1}\n      value={text}\n      onChange={e => setText(e.target.value)}\n      type=\"text\"\n      style={{width: '100%', boxSizing: 'border-box'}}\n    />\n  );\n};\n","import { useEffect, useState } from \"react\";\n\nexport const useKeyboard = (\n  handleEvent: (event: DocumentEventMap[\"keydown\"]) => void,\n  deps?: {}[]\n) => {\n  return useEffect(() => {\n    window.document.addEventListener(\"keydown\", handleEvent);\n    return () => {\n      window.document.removeEventListener(\"keydown\", handleEvent);\n    };\n  }, deps);\n};\n\nexport function useDebounce(value: any, delay: number) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n","import React, {useContext} from \"react\";\nimport {AppState, Dispatch} from \"./types\";\n\n// @ts-ignore\nconst CountContext = React.createContext();\n\nexport const SandboxContext = ({children, app, dispatch}: any) => {\n  return (\n    <CountContext.Provider value={[app, dispatch]}>\n      {children}\n    </CountContext.Provider>\n  );\n};\n\nexport const useAppStateFromContext = (): [AppState, Dispatch] => {\n  const contextValue = useContext(CountContext);\n  return contextValue as [AppState, Dispatch];\n};\n","export function nextItem<T>(array: T[], item: T) {\n  return array[array.indexOf(item) + 1];\n}\n\nexport function previousItem<T>(array: T[], item: T) {\n  return array[array.indexOf(item) - 1];\n}\n\nexport function contains<T>(array: T[] | undefined, item: T): boolean {\n  return !!array && array.indexOf(item) >= 0;\n}\n\nexport function last<T>(array: T[]) {\n  return array[array.length - 1];\n}\n\nexport function isLast<T>(array: T[], item: T) {\n  return array.indexOf(item) == array.length - 1;\n}\n\nexport function isFirst<T>(array: T[], item: T) {\n  return array.indexOf(item) == 0;\n}\n\nexport function insertBefore<T>(array: T[], insertBofore: T, valueToInsert: T): T[] {\n  const index = array.indexOf(insertBofore);\n  const copy = [...array];\n  copy.splice(index, 0, valueToInsert);\n  return copy;\n}\n\nexport function insertAfter<T>(array: T[], insertAfter: T, valueToInsert: T) {\n  const index = array.indexOf(insertAfter);\n  const copy = [...array];\n  copy.splice(index + 1, 0, valueToInsert);\n  return copy;\n}\n\n\nexport function getPrevious<T>(array: T[], item: T) {\n  const index = array.indexOf(item);\n  return array[index - 1];\n}\n\nexport function removeItem<T>(array: T[] | undefined, item: T) {\n  if (!array)\n    return [];\n  array.splice(array.indexOf(item), 1);\n}\n\nexport function swapLeft<T>(array: T[], item: T) {\n  const index = array.indexOf(item);\n\n  if (index == 0)\n    return array;\n\n  return [\n    ...array.slice(0, index - 1),\n    array[index],\n    array[index - 1],\n    ...array.slice(index + 1),\n  ];\n}\n\nexport function swapRight<T>(array: T[], item: T) {\n  const index = array.indexOf(item);\n\n  if (index == array.length - 1)\n    return array;\n\n  return [\n    ...array.slice(0, index),\n    array[index + 1],\n    array[index],\n    ...array.slice(index + 2),\n  ];\n}\n\n","import {AppState, TreeDefinition, TreeNode} from \"../types\";\nimport {contains, last} from \"../utils/array\";\n\nexport const getContext = (state: AppState, nodeId: string): string[] => {\n  if (state.rootNodes.indexOf(nodeId) >= 0) return state.rootNodes;\n  const parentKey = getParentKey(state, nodeId);\n  const {children} = state.nodes[parentKey];\n\n  if (!children)\n    throw new Error(\n      `No children found for ${nodeId} and it doesn't exist in the root`\n    );\n\n  return children;\n};\n\nexport interface Parent {\n  parent: string;\n  context: string[];\n}\n\nexport const getParentContext = (state: AppState, nodeId: string): Parent => {\n  let parentKey = getParentKey(state, nodeId);\n  while (\n    !isRoot(state, parentKey) &&\n    last(getContext(state, parentKey)) == parentKey\n    ) {\n    parentKey = getParentKey(state, parentKey);\n  }\n  return {parent: parentKey, context: getContext(state, parentKey)};\n};\n\nexport const getParentKey = (state: AppState, nodeId: string) => {\n  const key = Object.keys(state.nodes).find(key =>\n    contains(state.nodes[key].children, nodeId)\n  );\n  if (!key) throw new Error(`Couldn't find parent id for ${nodeId}`);\n  return key;\n};\n\nexport const getDeepestChild = (state: AppState, nodeId?: string) => {\n  let node = nodeId || last(state.rootNodes);\n  while (hasChildren(state, node) && !isNodeHidden(state, node)) {\n    node = last(getChildren(state, node));\n  }\n  return node;\n};\n\nexport const hasChildren = (state: AppState, nodeId: string) => {\n  const children = getChildren(state, nodeId);\n  return children && children.length > 0;\n};\n\nexport const getChildren = (state: AppState, nodeId: string): string[] => {\n  return state.nodes[nodeId].children || [];\n};\n\nexport const isRoot = (state: AppState, nodeId: string) =>\n  contains(state.rootNodes, nodeId);\n\nexport const appendNodes = (\n  tree: TreeNode,\n  nodeId: string,\n  newNodes: TreeDefinition[]\n): TreeNode => {\n  const newTree = {...tree};\n  newTree[nodeId] = {\n    ...newTree[nodeId],\n    children: newNodes.map(n => n.id)\n  };\n  newNodes.forEach(node => {\n    newTree[node.id] = node;\n  });\n  return newTree;\n};\n\nexport const updateNode = (\n  state: AppState,\n  nodeId: string,\n  props: Partial<TreeDefinition>\n) => {\n  return {\n    ...state,\n    nodes: {\n      ...state.nodes,\n      [nodeId]: {\n        ...state.nodes[nodeId],\n        ...props\n      }\n    }\n  };\n};\n\nexport const isNodeHidden = (state: AppState, nodeId: string) =>\n  state.nodes[nodeId].isChildrenHidden;\n\nexport const isNodeLoading = (state: AppState, nodeId: string) =>\n  state.nodes[nodeId].isLoading;\n\nexport const isEditingCurrentNode = (state: AppState) =>\n  state.nodes[state.selectedNode].isEditing;\n\nexport const createEmptyTree = (): AppState => ({\n  rootNodes: [],\n  selectedNode: '',\n  nodes: {}\n});\n","import {Action, AppState, TreeNode} from \"../types\";\nimport {useReducer} from \"react\";\nimport {getPrevious, insertBefore, isFirst, removeItem} from \"../utils/array\";\nimport {createEmptyTree, getContext, getParentKey, isRoot, updateNode} from \"./treeUtils\";\n\nexport const reducer = (state: AppState, action: Action): AppState => {\n\n  if (action.type === 'RESTORE') {\n    return action.savedState;\n  }\n\n  if (action.type === \"SET_NODES\") {\n    const {nodes} = action;\n    const tree: TreeNode = {};\n    nodes.forEach(v => {\n      tree[v.id] = {\n        ...v\n      };\n    });\n    return {\n      selectedNode: nodes[0].id,\n      nodes: tree,\n      rootNodes: nodes.map(v => v.id)\n    };\n  }\n  //TODO: consider to remove thoose into separate reducer\n  if (action.type == \"EditNode\") {\n    return updateNode(state, action.nodeId, action.props);\n  }\n  if (action.type == \"CreateNode\") {\n    const newId = action.props.id || Math.random() + '';\n    const withNode = updateNode(state, newId, {\n      ...action.props,\n      id: newId,\n    });\n    if (state.rootNodes.length === 0 || isRoot(state, action.placeBefore)) {\n      withNode.rootNodes = insertBefore(withNode.rootNodes, action.placeBefore, newId);\n    } else {\n      withNode.nodes[getParentKey(state, action.placeBefore)] = {\n        ...withNode.nodes[getParentKey(state, action.placeBefore)],\n        children:\n        // @ts-ignore\n          insertBefore(withNode.nodes[getParentKey(state, action.placeBefore)].children, action.placeBefore, newId)\n      };\n    }\n    withNode.selectedNode = newId;\n    return withNode;\n  }\n\n  if (action.type == 'Delete') {\n    const context = getContext(state, action.nodeId);\n\n    //Roots are tricky special cases\n    if (isRoot(state, action.nodeId) && context.length === 1) {\n      return createEmptyTree();\n    }\n\n\n    // const parent =\n    const newnodes = {\n      ...state.nodes,\n    };\n\n    let nextSelectedNode: string;\n    if (context.length === 1) {\n      nextSelectedNode = getParentKey(state, action.nodeId);\n    } else if (isFirst(context, action.nodeId)) {\n      nextSelectedNode = context[1];\n    } else {\n      nextSelectedNode = getPrevious(context, action.nodeId);\n    }\n\n    deleteAllChildren(newnodes, action.nodeId);\n\n    delete newnodes[action.nodeId];\n\n\n    //TODO: remove state mutation\n    let newRoot = state.rootNodes;\n    if (isRoot(state, action.nodeId)) {\n      removeItem(newRoot, action.nodeId);\n    } else {\n      removeItem(newnodes[getParentKey(state, action.nodeId)].children, action.nodeId);\n    }\n\n    return {\n      ...state,\n      rootNodes: newRoot,\n      selectedNode: nextSelectedNode,\n      nodes: newnodes\n    }\n  }\n\n  if (action.type === 'SELECT_NODE') {\n    return {\n      ...state,\n      selectedNode: action.nodeId\n    }\n  }\n  if (action.type === 'SET_CHILDREN') {\n    const nodeId = action.parentId;\n    const newState: AppState = {\n      ...state,\n      nodes: {\n        ...state.nodes,\n        [nodeId]: {\n          ...state.nodes[nodeId],\n          children: action.children.map(c => c.id)\n        }\n      },\n    };\n    action.children.forEach(child => {\n      newState.nodes[child.id] = child;\n    });\n\n    return newState;\n  }\n\n  if (action.type === 'SET_ROOTS') {\n    return {\n      ...state,\n      rootNodes: action.roots\n    }\n  }\n  return state;\n};\n\nconst deleteAllChildren = (tree: TreeNode, nodeId: string) => {\n  const children = tree[nodeId].children;\n  if (children) {\n    children.forEach(c => {\n      deleteAllChildren(tree, c);\n\n      delete tree[c];\n    });\n  }\n};\n\nexport const useAppState = () => {\n  return useReducer(reducer, createEmptyTree());\n};\n","import {Action, AppStateActionCreator, TreeDefinition} from \"../types\";\n\nexport const createNode: AppStateActionCreator = (state, dispatch) => {\n  dispatch({\n    type: \"CreateNode\",\n    placeBefore: state.selectedNode,\n    props: {text: 'New Node', isEditing: true}\n  });\n};\n\nexport const deleteNode: AppStateActionCreator = (state, dispatch) => {\n  dispatch({\n    type: \"Delete\",\n    nodeId: state.selectedNode\n  });\n};\n\nexport const startEditNode = (nodeId: string): Action =>\n  editAction(nodeId, {isEditing: true});\n\nexport const stopEditNode = (nodeId: string): Action =>\n  editAction(nodeId, {isEditing: false});\n\nexport const showChildren = (nodeId: string): Action =>\n  editAction(nodeId, {isChildrenHidden: false});\n\nexport const hideChildren = (nodeId: string): Action =>\n  editAction(nodeId, {isChildrenHidden: true});\n\nexport const startLoading = (nodeId: string): Action =>\n  editAction(nodeId, {isLoading: true});\n\nexport const endLoading = (nodeId: string): Action =>\n  editAction(nodeId, {isLoading: false});\n\nexport const setChildren = (nodeId: string, children: string[]): Action =>\n  editAction(nodeId, {children});\n\nexport const setRoots = (roots: string[]): Action => ({\n  type:'SET_ROOTS',\n  roots\n});\n\nconst editAction = (nodeId: string, props: Partial<TreeDefinition>): Action => ({\n  type: \"EditNode\",\n  nodeId,\n  props\n});\n\nexport const selectNode = (nodeId: string): Action => ({type: 'SELECT_NODE', nodeId});\n","import {Action, AppState, AppStateActionCreator, Dispatch, TreeDefinition} from \"../types\";\nimport {\n  getChildren,\n  getContext,\n  getDeepestChild,\n  getParentContext,\n  getParentKey,\n  hasChildren,\n  isEditingCurrentNode,\n  isNodeHidden,\n  isNodeLoading,\n  isRoot\n} from \"../state/treeUtils\";\nimport {isFirst, isLast, nextItem, previousItem} from \"../utils/array\";\nimport {endLoading, hideChildren, selectNode, showChildren, startLoading, stopEditNode} from \"./actions\";\nimport {fetchSimilarVideos, Video} from \"../api\";\n\ntype Codes = {\n  [id: string]: AppStateActionCreator | undefined;\n}\n\nconst codes: Codes = {\n  'ArrowDown': moveNodeDown,\n  'ArrowUp': moveNodeUp,\n  'ArrowRight': moveNodeRight,\n  'ArrowLeft': moveNodeLeft,\n};\n\nexport const handleTraversal = (event: KeyboardEvent, state: AppState, dispatch: Dispatch) => {\n  if (state.rootNodes.length === 0)\n    return;\n\n  const handler = codes[event.code];\n  if (handler) {\n    //TODO: add a handler to check if we are going to move away\n    //or maybe each handler would return true or false if the node moved away\n    //note that stopEditNode is using selected node\n    //Currently you are going to stop editing even if you click down with only one item in a list\n    if (isEditingCurrentNode(state)) {\n      dispatch(stopEditNode(state.selectedNode));\n    }\n\n    handler(state, dispatch);\n  }\n};\n\nfunction moveNodeDown(state: AppState, dispatch: Dispatch) {\n  if (getDeepestChild(state) === state.selectedNode)\n    return;\n\n  if (\n    hasChildren(state, state.selectedNode) &&\n    !isNodeHidden(state, state.selectedNode)\n  ) {\n    dispatch(selectNode(getChildren(state, state.selectedNode)[0]));\n  } else {\n    const context = getContext(state, state.selectedNode);\n    if (isLast(context, state.selectedNode)) {\n      const parentContext = getParentContext(state, state.selectedNode);\n      dispatch(selectNode(nextItem(parentContext.context, parentContext.parent)));\n    } else {\n      dispatch(selectNode(nextItem(context, state.selectedNode)));\n    }\n  }\n}\n\nfunction moveNodeUp(state: AppState, dispatch: Dispatch) {\n  if (isFirst(state.rootNodes, state.selectedNode))\n    return;\n\n  const context = getContext(state, state.selectedNode);\n  if (isFirst(context, state.selectedNode)) {\n    dispatch(selectNode(getParentKey(state, state.selectedNode)));\n  } else {\n    const previousNode = previousItem(context, state.selectedNode);\n    dispatch(selectNode(getDeepestChild(state, previousNode)));\n  }\n}\n\n\nfunction moveNodeRight(state: AppState, dispatch: Dispatch) {\n  if (isNodeLoading(state, state.selectedNode))\n    return;\n\n  if (!hasChildren(state, state.selectedNode)) {\n    dispatch(startLoading(state.selectedNode));\n\n    fetchSimilarVideos(state.nodes[state.selectedNode].youtubeId as string)\n      .then((videos) => {\n        dispatch(endLoading(state.selectedNode));\n        dispatch(setVideosAsChildren(state.selectedNode, videos))\n      });\n  } else if (isNodeHidden(state, state.selectedNode)) {\n    dispatch(showChildren(state.selectedNode));\n  } else {\n    return dispatch(selectNode(getChildren(state, state.selectedNode)[0]));\n  }\n}\n\n\nfunction moveNodeLeft(state: AppState, dispatch: Dispatch) {\n  if (\n    !isNodeHidden(state, state.selectedNode) &&\n    hasChildren(state, state.selectedNode)\n  ) {\n    dispatch(hideChildren(state.selectedNode));\n  } else if (!isRoot(state, state.selectedNode)) {\n    dispatch(selectNode(getParentKey(state, state.selectedNode)))\n  }\n}\n\nexport const setVideosAsChildren = (nodeId: string, videos: Video[]): Action => {\n  const children: TreeDefinition[] = videos.map(video =>\n    ({id: Math.random() + '', text: video.text, youtubeId: video.id})\n  );\n  return {\n    type: \"SET_CHILDREN\",\n    parentId: nodeId,\n    children\n  }\n};\n\n","import {AppState, Dispatch} from \"../types\";\nimport {getParentKey, isRoot} from \"../state/treeUtils\";\nimport {getPrevious, insertAfter, isFirst, removeItem, swapLeft, swapRight} from \"../utils/array\";\nimport {setChildren, setRoots} from \"./actions\";\n\nexport const swapSelectedNodeDown = (state: AppState, dispatch: Dispatch) => {\n  applySwapMove(state, dispatch, swapRight);\n};\n\nexport const swapSelectedNodeUp = (state: AppState, dispatch: Dispatch) => {\n  applySwapMove(state, dispatch, swapLeft);\n};\n\nexport const swapSelectedNodeRight = (state: AppState, dispatch: Dispatch) => {\n  const context = isRoot(state, state.selectedNode) ?\n    state.rootNodes :\n    getChildren(state, getParentKey(state, state.selectedNode));\n\n  if (!isFirst(context, state.selectedNode)) {\n    removeSelectedFromContext(state, dispatch, context);\n    appendSelectedToPreviousNode(state, dispatch, context);\n  }\n};\n\nexport const swapSelectedNodeLeft = (state: AppState, dispatch: Dispatch) => {\n  if (!isRoot(state, state.selectedNode)) {\n    const parent = getParentKey(state, state.selectedNode);\n\n    insertSelectedInParent(state, dispatch, parent);\n    removeSelectedFromContext(state, dispatch, getChildren(state, parent));\n  }\n};\n\nconst applySwapMove = (state: AppState, dispatch: Dispatch, swap: (context: string[], nodeId: string) => string[]) => {\n  if (isRoot(state, state.selectedNode)) {\n    dispatch(setRoots(swap(state.rootNodes, state.selectedNode)));\n  } else {\n\n    const parent = getParentKey(state, state.selectedNode);\n    const children = getChildren(state, parent);\n\n    dispatch(setChildren(parent, swap(children, state.selectedNode)));\n  }\n};\n\nconst removeSelectedFromContext = (state: AppState, dispatch: Dispatch, context: string[]) => {\n  const newRoots = [...context];\n  removeItem(newRoots, state.selectedNode);\n  if (isRoot(state, state.selectedNode)) {\n    dispatch(setRoots(newRoots));\n  } else {\n    dispatch(setChildren(getParentKey(state, state.selectedNode), newRoots));\n  }\n};\n\nconst insertSelectedInParent = (state: AppState, dispatch: Dispatch, parentId: string) => {\n  let children: string[];\n  if (isRoot(state, parentId)) {\n    children = state.rootNodes;\n  } else {\n    const grandParent = getParentKey(state, parentId);\n    children = getChildren(state, grandParent);\n  }\n  const newChildren = insertAfter(children, parentId, state.selectedNode);\n  if (isRoot(state, parentId)) {\n    dispatch(setRoots(newChildren));\n  } else {\n    dispatch(setChildren(getParentKey(state, parentId), newChildren));\n  }\n};\n\nconst appendSelectedToPreviousNode = (state: AppState, dispatch: Dispatch, context: string[]) => {\n  const previousNode = getPrevious(context, state.selectedNode);\n  dispatch(setChildren(previousNode, getChildren(state, previousNode).concat([state.selectedNode])))\n};\n\nconst getChildren = (state: AppState, nodeId: string): string[] =>\n  state.nodes[nodeId].children || [] as string[]\n","import {AppState, Dispatch} from \"../types\";\nimport {handleTraversal} from \"./traversal\";\nimport {createNode, deleteNode, startEditNode, stopEditNode} from \"./actions\";\nimport {isEditingCurrentNode} from \"../state/treeUtils\";\nimport {swapSelectedNodeDown, swapSelectedNodeLeft, swapSelectedNodeRight, swapSelectedNodeUp} from \"./nodeSwap\";\n\nexport const onKeyPress = (event: KeyboardEvent, state: AppState, dispatch: Dispatch) => {\n  if (event.code === 'Enter') {\n    if (state.rootNodes.length > 0 && isEditingCurrentNode(state)) {\n      dispatch(stopEditNode(state.selectedNode));\n    } else {\n      createNode(state, dispatch);\n    }\n  }\n\n  //do not handle any more nodes\n  if (state.rootNodes.length > 0 && isEditingCurrentNode(state)) {\n    return;\n  }\n\n\n  if (isSwapping(event, 'ArrowDown')) {\n    swapSelectedNodeDown(state, dispatch);\n  } else if (isSwapping(event, 'ArrowUp')) {\n    swapSelectedNodeUp(state, dispatch);\n  } else if (isSwapping(event, 'ArrowLeft')) {\n    swapSelectedNodeLeft(state, dispatch);\n  } else if (isSwapping(event, 'ArrowRight')) {\n    swapSelectedNodeRight(state, dispatch);\n  } else {\n    handleTraversal(event, state, dispatch);\n  }\n\n  if (event.code === 'F2') {\n    dispatch(startEditNode(state.selectedNode));\n  }\n  if (event.code === 'Backspace') {\n    deleteNode(state, dispatch);\n  }\n};\n\n\nconst isSwapping = (event: KeyboardEvent, key: string) =>\n  event.shiftKey && event.metaKey && event.code === key;\n\n\n","import * as React from 'react';\n\nimport Youtube from 'react-youtube';\n\ninterface Props {\n  visible: boolean;\n  id?: string;\n}\n\nexport default ({visible, id}: Props) => {\n  if (!id)\n    return null;\n\n  const opts: any = {\n    height: 150,\n    width: 220,\n    playerVars: { // https://developers.google.com/youtube/player_parameters\n      autoplay: 1\n    }\n  };\n  return (\n    <div style={{position: 'absolute', right: 15, bottom: 15, display: visible ? undefined : 'none'}}>\n      <Youtube\n        videoId={id}\n        opts={opts}\n        // onEnd={this.props.onEnd}\n        // onReady={(e: any) => this.props.onReady(e.target)}\n      />\n    </div>\n  );\n}\n","import {useReducer} from \"react\";\n\ninterface PlayerState {\n  isPlaying: boolean\n  youtubeVideoId?: string;\n}\n\ninterface PlayAction {\n  type: 'PLAY',\n  youtubeVideoId: string;\n}\n\ninterface StopAction {\n  type: 'STOP'\n}\n\ntype PlayerAction = PlayAction | StopAction;\n\nconst reducer = (state: PlayerState, action: PlayerAction): PlayerState => {\n  if (action.type === 'PLAY') {\n    return {\n      ...state,\n      isPlaying: true,\n      youtubeVideoId: action.youtubeVideoId\n    }\n  }\n  if (action.type === 'STOP') {\n    return {\n      ...state,\n      isPlaying: false,\n      youtubeVideoId: undefined\n    }\n  }\n  return state;\n};\n\nexport const usePlayer = () => {\n  return useReducer(reducer, {isPlaying: false});\n};\n","import React, {useState} from \"react\";\nimport {useKeyboard} from \"../utils/hooks\";\n\ninterface Props {\n  onKeyPress: (event: KeyboardEvent) => void;\n  tabIndex: number;\n  children: any;\n}\n\nexport default ({onKeyPress, tabIndex, children}: Props) => {\n  const [focus, setFocus] = useState(false);\n\n  useKeyboard(\n    event => {\n      if (focus) {\n        onKeyPress(event);\n      }\n    });\n\n  return (\n    <div\n      className=\"area\"\n      style={{flex: 1}}\n      tabIndex={tabIndex}\n      onFocus={() => setFocus(true)}\n      onBlur={() => setFocus(false)}\n    >\n      {children}\n    </div>\n  );\n};\n","import React, {useEffect, useRef} from \"react\";\nimport {useAppStateFromContext} from \"../SandboxContext\";\n\ninterface RowItemProps {\n  level?: number;\n  nodeId: string;\n}\n\nexport const RowItem = ({level, nodeId}: RowItemProps) => {\n  const [app, dispatch] = useAppStateFromContext();\n\n  const node = app.nodes[nodeId];\n  const isSelected = app.selectedNode === nodeId;\n\n  const txt1 = useRef(null);\n\n  useEffect(() => {\n    const {current} = txt1 as any;\n    if (current && node.isEditing) {\n      current.focus();\n    }\n  }, [node.isEditing]);\n\n  return (\n    <div\n      style={{\n        fontWeight: isSelected ? 600 : undefined,\n        paddingLeft: level ? level * 20 : undefined,\n        backgroundColor: isSelected ? \"#c3c3c3\" : undefined\n      }}\n    >\n      {node.isEditing ? (\n        <input\n          ref={txt1}\n          type=\"text\"\n          value={node.text}\n          tabIndex={4}\n          onBlur={() =>\n            dispatch({\n              type: \"EditNode\",\n              nodeId: nodeId,\n              props: {isEditing: false}\n            })\n          }\n          onChange={e =>\n            dispatch({\n              type: \"EditNode\",\n              nodeId: nodeId,\n              props: {text: e.target.value}\n            })\n          }\n        />\n      ) : (\n        node.text\n      )}\n      {node.isLoading && <i> (Loading...)</i>}\n      {node.isChildrenHidden && \"...\"}\n    </div>\n  );\n};\n","import React, {Fragment} from \"react\";\nimport {TreeNode} from \"../types\";\nimport {RowItem} from \"./RowItem\";\n\ninterface Props {\n  nodes: TreeNode;\n  nodesToShow: string[];\n  selectedId: string;\n  level?: number;\n}\n\nexport const List = ({nodes, selectedId, nodesToShow, level = 0}: Props) => (\n  <Fragment>\n    {nodesToShow.map(n => (\n      <Fragment key={n}>\n        <RowItem nodeId={n} level={level}/>\n        {nodes[n].children && !nodes[n].isChildrenHidden && (\n          <List\n            nodes={nodes}\n            nodesToShow={nodes[n].children as string[]}\n            selectedId={selectedId}\n            level={level + 1}\n          />\n        )}\n      </Fragment>\n    ))}\n  </Fragment>\n);\n\n","import {AppState} from \"../types\";\nimport {List} from \"./List\";\nimport React from \"react\";\n\nexport default ({app}: { app: AppState }) => (\n  <List\n    nodes={app.nodes}\n    nodesToShow={app.rootNodes}\n    selectedId={app.selectedNode}\n  />\n);\n","import React, {useEffect} from \"react\";\nimport SearchInput from \"./Search/SearchInput\";\nimport {SandboxContext} from \"./SandboxContext\";\nimport {useAppState} from \"./state/reducer\";\nimport {onKeyPress} from \"./keyHandlers\";\nimport YoutubePlayer from \"./components/Player\";\nimport {usePlayer} from \"./state/player\";\nimport {AppState} from \"./types\";\nimport {isEditingCurrentNode} from \"./state/treeUtils\";\nimport Focusable from \"./components/Focusable\";\nimport Tree from \"./components/Tree\";\n\nconst App = () => {\n  const [searchNodes, searchDispatch] = useAppState();\n  const [favoritesNodes, favoritesDispatch] = useAppState();\n\n  const [playerState, dispatchPlayAction] = usePlayer();\n\n  const handlePlayerKeys = (event: KeyboardEvent, context: AppState) => {\n    if (event.code === 'KeyP' && !isEditingCurrentNode(context)) {\n      const node = context.nodes[context.selectedNode];\n      if (!node.youtubeId) {\n        console.warn(node, \"Expected to have 'youtubeId' property, but it didn't\");\n      } else {\n        dispatchPlayAction({type: 'PLAY', youtubeVideoId: node.youtubeId})\n      }\n    }\n  };\n\n  const onSearchKeyPressHandler = (event: KeyboardEvent) => {\n    if (event.code === 'KeyD' && !isEditingCurrentNode(searchNodes)) {\n      favoritesDispatch({\n        type: 'CreateNode',\n        placeBefore: favoritesNodes.rootNodes[0],\n        props: {\n          ...searchNodes.nodes[searchNodes.selectedNode],\n          children: [],\n          id: Math.random() + '',\n        }\n      });\n    }\n    handlePlayerKeys(event, searchNodes);\n    onKeyPress(event, searchNodes, searchDispatch);\n  };\n\n  const onFavoritesKeyPressHandler = (event: KeyboardEvent) => {\n    handlePlayerKeys(event, favoritesNodes);\n    onKeyPress(event, favoritesNodes, favoritesDispatch);\n  };\n\n  useEffect(() => {\n    const saved = localStorage.getItem('favorites');\n    if (saved) {\n      favoritesDispatch({\n        type: 'RESTORE',\n        savedState: JSON.parse(saved)\n      });\n    }\n  }, []);\n\n  useEffect(() => {\n    localStorage.setItem('favorites', JSON.stringify(favoritesNodes));\n  }, [favoritesNodes]);\n\n  return (\n    <div>\n      <div style={{flexDirection: 'row', display: 'flex', alignItems: 'stretch', height: '100vh'}}>\n        <div style={{flex: 1, display: 'flex', flexDirection: 'column'}}>\n          <SearchInput onSearched={nodes => searchDispatch({type: \"SET_NODES\", nodes})}/>\n          <Focusable tabIndex={2} onKeyPress={onSearchKeyPressHandler}>\n            <SandboxContext app={searchNodes} dispatch={searchDispatch}>\n              <Tree app={searchNodes}/>\n            </SandboxContext>\n          </Focusable>\n        </div>\n        <Focusable tabIndex={3} onKeyPress={onFavoritesKeyPressHandler}>\n          <SandboxContext app={favoritesNodes} dispatch={favoritesDispatch}>\n            <div style={{textAlign: 'center'}}>Favorites</div>\n            <Tree app={favoritesNodes}/>\n          </SandboxContext>\n        </Focusable>\n      </div>\n      <YoutubePlayer visible id={playerState.youtubeVideoId}/>\n    </div>\n  );\n};\n\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit http://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See http://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}